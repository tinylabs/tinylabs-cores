class Signal(object):
    def __init__(self, name, width=0, low=0, asc=False, prepend=''):
        self.name = name
        self.width=width
        self.low = low
        self.asc = asc
        self.prepend = prepend

    def range(self):
        if self.width > 0:
            l = self.width+self.low-1
            r = self.low
            if self.asc:
                return '['+str(r)+':'+str(l)+']'
            else:
                return '['+str(l)+':'+str(r)+']'
        return ''

class Wire(Signal):
    def write(self, width):
        return 'wire{range} {prepend} {name};\n'.format(range=self.range().rjust(width), name=self.name, prepend=self.prepend)

class Logic(Signal):
    def write(self, width):
        return 'logic{range} {name};\n'.format(range=self.range().rjust(width), name=self.name)

class ModulePort(Signal):
    def __init__(self, name, dir, width=0, low=0, asc=False):
        super(ModulePort, self).__init__(name, width, low, asc)
        self.dir = dir

    def write(self, range_width=0):
        return '{dir} {range} {name}'.format(dir=self.dir.ljust(6), range=self.range().rjust(range_width), name=self.name)

class LocalParam:
    def __init__(self, name, val):
        self.name = name
        self.val = val
    def write(self):
        return 'localparam {name} = {val};\n'.format (name=self.name, val=self.val)

class Assign:
    def __init__(self, name, val, width=0):
        self.name = name
        self.val = val
        self.width = width
    def convert(self):
        if self.width:
            return '{0}\'h{1}'.format (self.width, hex((self.val + (1 << self.width)) % (1 << self.width))[2:])
        else:
            return self.val
    def write(self):
        return 'assign {name} = {val};\n'.format (name=self.name, val=self.convert())

class Instance:
    def __init__(self, module, name, parameters, ports):
        self.module = module
        self.name = name
        self.parameters = parameters
        self.ports = ports

    def write(self):
        s = self.module
        if self.parameters:
            max_len = max([len(p.name) for p in self.parameters])
            s += '\n  #('
            s += ',\n    '.join(['.' + p.name.ljust(max_len) +' (' + str(p.value) + ')' for p in self.parameters])
            s += ')\n'
        s += ' ' + self.name

        if self.ports:
            s += '\n   ('
            max_len = max([len(p.name) for p in self.ports])
            s += ',\n    '.join(['.' + p.name.ljust(max_len) +' (' + str(p.value) + ')' for p in self.ports])
            s += ')'
        s += ';\n'
        return s

class VerilogWriter:
    def __init__(self, name):
        self.name = name
        self.instances = []
        self.ports = []
        self.wires = []
        self.lp = []
        self.assign = []
        self.logic = []
        
    def add(self, obj):
        if isinstance(obj, Instance):
            self.instances += [obj]
        elif isinstance(obj, ModulePort):
            self.ports += [obj]
        elif isinstance(obj, Wire):
            self.wires += [obj]
        elif isinstance(obj, Logic):
            self.logic += [obj]
        elif isinstance(obj, LocalParam):
            self.lp += [obj]
        elif isinstance(obj, Assign):
            self.assign += [obj]
        else:
            raise Exception("Invalid type!" + str(obj))

    def write(self, file=None):
        s = ("// THIS FILE IS AUTOGENERATED BY ahb3lite_csr_gen\n"
             "// ANY MANUAL CHANGES WILL BE LOST\n")
        if self.ports:
            s += "module {name}\n".format(name=self.name)
            max_len = max([len(p.range()) for p in self.ports])
            s += '   ('
            s += ',\n    '.join([p.write(max_len) for p in self.ports])
            s += ')'
            s += ';\n\n'
        if self.lp:
            for lp in self.lp:
                s += lp.write ()
            s += '\n'
        if self.wires:
            max_len = max([len(w.range()) for w in self.wires])
            for w in self.wires:
                s += w.write(max_len + 1)
            s +='\n'
        if self.logic:
            max_len = max([len(w.range()) for w in self.logic])
            for w in self.logic:
                s += w.write(max_len + 1)
            s +='\n'
        if self.assign:
            for a in self.assign:
                s += a.write ()
            s += '\n'
        for i in self.instances:
            s += i.write()
            s += '\n'
        if self.ports:
            s += 'endmodule\n'
        if file is None:
            return s
        else:
            f = open(file,'w')
            f.write(s)
